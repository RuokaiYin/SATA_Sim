import yaml
import shutil
import os
import subprocess
import re
from collections import OrderedDict


def extract_info(filename):
    with open(filename, 'r') as file:
        data = yaml.safe_load(file)

    architecture_name = data.get('architecture', {}).get('name', 'default')
    sram_info = {}
    dram_info = {}

    # Navigate through the architecture hierarchy
    subtrees = data.get('architecture', {}).get('subtree', [])
    for subtree in subtrees:
        locals_ = subtree.get('local', [])
        for local in locals_:
            attributes = local.get('attributes', {})
            
            # Extract SRAM info
            if attributes.get('kernel') == 'sram':
                name = local.get('name')
                if name:
                    sram_info[name] = {
                        "WIDTH": attributes.get('width'),
                        "BYTES": attributes.get('size-bytes'),
                        "BANK": attributes.get('bank')
                    }

            # Extract DRAM info
            if attributes.get('kernel') == 'dram':
                name = local.get('name')
                if name:
                    dram_info[name] = {
                        "WIDTH": attributes.get('width'),
                        "BYTES": attributes.get('size-bytes'),
                        "BANK": attributes.get('bank')
                    }

    return architecture_name, sram_info, dram_info

def generate_config_files(architecture_name, info, config_type):
    # Create directory if it doesn't exist
    output_dir = f"../cacti/{config_type}-config/{architecture_name}-{config_type}-configs"
    os.makedirs(output_dir, exist_ok=True)

    for name, attributes in info.items():
        # Copy default config to new file
        new_filename = os.path.join(output_dir, f"{config_type}-config-{name}.cfg")
        shutil.copy(f"../cacti/{config_type}-config/{config_type}-config.cfg", new_filename)

        # Replace placeholders with actual values
        with open(new_filename, 'r') as file:
            content = file.read()
            if config_type == "sram":
                content = content.replace('-size (bytes) y', f'-size (bytes) {attributes["BYTES"]}')
                content = content.replace('-UCA bank count z', f'-UCA bank count {attributes["BANK"]}')
                content = content.replace('-block size (bytes) i', f'-block size (bytes) {attributes["WIDTH"]}')
            elif config_type == "dram":
                content = content.replace('-size (bytes) y', f'-size (bytes) {attributes["BYTES"]}')
                content = content.replace('-UCA bank count z', f'-UCA bank count {attributes["BANK"]}')
                content = content.replace('-block size (bytes) i', f'-block size (bytes) {attributes["WIDTH"]}')

        # Write updated content back to the file
        with open(new_filename, 'w') as file:
            file.write(content)

def run_cacti_simulation(architecture_name, config_type):
    # Set the directory for the config files
    config_dir = f"../cacti/{config_type}-config/{architecture_name}-{config_type}-configs"
    
    # List all the config files in the directory
    config_files = [f for f in os.listdir(config_dir) if f.endswith('.cfg')]
    # Change directory to ../cacti
    os.chdir('../cacti')
    
    print(f"Running {config_type} simulations...")  # Debugging print
    
    for config_file in config_files:
        # Construct the full path for the config file
        config_path = os.path.join(config_dir, config_file)
        
        # Construct the path for the output file
        out_path = os.path.join(config_dir, config_file.replace('.cfg', '.log'))
        
        print(f"Running Cacti simulation for {config_file}...")  # Debugging print
        
        # Run the Cacti command with tee
        subprocess.run(f'./cacti -infile {config_path} | tee {out_path}', shell=True)

        os.chdir(f'./{config_type}-config/{architecture_name}-{config_type}-configs')

        # Delete any .out files generated by Cacti in the current directory (if any)
        for file in os.listdir():
            if file.endswith('.out') or file.endswith('.cfg.out'):
                os.remove(file)
        os.chdir('../..')

def extract_data_from_log(log_path, keywords):
    results = {}
    with open(log_path, 'r') as file:
        content = file.readlines()
    for line in content:
        for keyword, yaml_key in keywords.items():
            if keyword in line:
                # print(yaml_key)
                # Extract the numeric value from the line and convert to float
                value = float(re.search(r"[-+]?\d*\.\d+|\d+", line).group())
                results[yaml_key] = value
    # print(results)
    return results

def extract_dram_data(architecture_name):
    results = []
    dram_log_dir = f'../cacti/dram-config/{architecture_name}-dram-configs'
    log_files = [f for f in os.listdir(dram_log_dir) if f.endswith('.log')]
    dram_keywords = {
        "Read energy": "read energy"
    }
    for log_file in log_files:
        log_path = os.path.join(dram_log_dir, log_file)
        dram_name = log_file.replace("dram-config-", "").replace(".log", "")
        dram_results = extract_data_from_log(log_path, dram_keywords)
        # Use OrderedDict to ensure order
        ordered_results = OrderedDict([
            ("name", dram_name),
            ("read energy", dram_results["read energy"])
        ])
        results.append(ordered_results)
    shutil.rmtree(dram_log_dir)
    return results

def extract_sram_data(architecture_name):
    results = []
    sram_log_dir = f"../cacti/sram-config/{architecture_name}-sram-configs"
    log_files = [f for f in os.listdir(sram_log_dir) if f.endswith('.log')]
    sram_keywords = {
        "Total dynamic read energy per access (nJ):": "read dynamic energy",
        "Total dynamic write energy per access (nJ):": "write dynamic energy",
        "Total leakage power of a bank (mW):": "leakage power"
    }
    for log_file in log_files:
        log_path = os.path.join(sram_log_dir, log_file)
        sram_name = log_file.replace("sram-config-", "").replace(".log", "")
        sram_results = extract_data_from_log(log_path, sram_keywords)
        # Use OrderedDict to ensure order
        ordered_results = OrderedDict([
            ("name", sram_name),
            ("read dynamic energy", sram_results["read dynamic energy"]),
            ("write dynamic energy", sram_results["write dynamic energy"]),
            ("leakage power", sram_results["leakage power"])
        ])
        results.append(ordered_results)
    # print(results)
    shutil.rmtree(sram_log_dir)
    
    return results

# Add a custom representer for OrderedDict
def represent_ordereddict(dumper, data):
    return dumper.represent_mapping('tag:yaml.org,2002:map', data.items())

yaml.add_representer(OrderedDict, represent_ordereddict)

def store_results_to_yaml(dram_data, sram_data):
    results = {
        "DRAM": dram_data,
        "SRAM": sram_data
    }
    # Save the results to a YAML file
    os.chdir(original_directory)
    with open("results/mem-stat.yaml", 'w') as file:
        yaml.dump(results, file)

if __name__ == "__main__":
    # Capture the original directory
    original_directory = os.getcwd()
    architecture_name, sram_data, dram_data = extract_info('sata-config.yaml')
    generate_config_files(architecture_name, sram_data, "sram")
    generate_config_files(architecture_name, dram_data, "dram")
    run_cacti_simulation(architecture_name, "sram")
    run_cacti_simulation(architecture_name, "dram")
    # extract_dram_energy(architecture_name, "dram")
    dram_results = extract_dram_data(architecture_name)
    sram_results = extract_sram_data(architecture_name)

    # Store the results to a YAML file
    store_results_to_yaml(dram_results, sram_results)
